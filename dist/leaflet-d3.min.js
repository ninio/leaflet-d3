/*! @asymmetrik/leaflet-d3 - 3.1.1 - Copyright (c) 2007-2017 Asymmetrik Ltd, a Maryland Corporation */
!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("d3"),require("d3-hexbin"),require("leaflet")):"function"==typeof define&&define.amd?define(["exports","d3","d3-hexbin","leaflet"],n):n(t.leafletD3={},t.d3,t.d3.hexbin)}(this,function(t,u,n){"use strict";
/**
 * This is a convoluted way of getting ahold of the hexbin function.
 * - When imported globally, d3 is exposed in the global namespace as 'd3'
 * - When imported using a module system, it's a named import (and can't collide with d3)
 * - When someone isn't importing d3-hexbin, the named import will be undefined
 *
 * As a result, we have to figure out how it's being imported and get the function reference
 * (which is why we have this convoluted nested ternary statement
 */var i=null!=u.hexbin?u.hexbin:null!=n?n.hexbin:null;
/**
 * L is defined by the Leaflet library, see git://github.com/Leaflet/Leaflet.git for documentation
 * We extend L.SVG to take advantage of built-in zoom animations.
 */L.HexbinLayer=L.SVG.extend({includes:[L.Events],
/**
	 * Default options
	 */
options:{radius:12,opacity:.6,duration:200,colorScaleExtent:[1,void 0],radiusScaleExtent:[1,void 0],colorRange:["#f7fbff","#08306b"],radiusRange:[4,12],pointerEvents:"all"},
/**
	 * Standard Leaflet initialize function, accepting an options argument provided by the
	 * user when they create the layer
	 * @param options Options object where the options override the defaults
	 */
initialize:function(t){L.setOptions(this,t),
// Set up the various overrideable functions
this._fn={lng:function(t){return t[0]},lat:function(t){return t[1]},colorValue:function(t){return t.length},radiusValue:function(t){return Number.MAX_VALUE},fill:function(t){var n=this._fn.colorValue(t);return null!=n?this._scale.color(n):"none"}},
// Set up the customizable scale
this._scale={color:u.scaleLinear(),radius:u.scaleLinear()},
// Set up the Dispatcher for managing events and callbacks
this._dispatch=u.dispatch("mouseover","mouseout","click"),
// Set up the default hover handler
this._hoverHandler=L.HexbinHoverHandler.none(),
// Create the hex layout
this._hexLayout=i().radius(this.options.radius).x(function(t){return t.point[0]}).y(function(t){return t.point[1]}),
// Initialize the data array to be empty
this._data=[],this._scale.color.range(this.options.colorRange).clamp(!0),this._scale.radius.range(this.options.radiusRange).clamp(!0)},
/**
	 * Callback made by Leaflet when the layer is added to the map
	 * @param map Reference to the map to which this layer has been added
	 */
onAdd:function(t){L.SVG.prototype.onAdd.call(this),
// Redraw on moveend
(
// Store a reference to the map for later use
this._map=t).on({moveend:this.redraw},this),
// Initial draw
this.redraw()},
/**
	 * Callback made by Leaflet when the layer is removed from the map
	 * @param map Reference to the map from which this layer is being removed
	 */
onRemove:function(t){L.SVG.prototype.onRemove.call(this),
// Destroy the svg container
this._destroyContainer(),
// Remove events
t.off({moveend:this.redraw},this),this._map=null},
/**
	 * Create the SVG container for the hexbins
	 * @private
	 */
_initContainer:function(){L.SVG.prototype._initContainer.call(this),this._d3Container=u.select(this._container).select("g")},
/**
	 * Clean up the svg container
	 * @private
	 */
_destroyContainer:function(){
// Don't do anything
},
/**
	 * (Re)draws the hexbins data on the container
	 * @private
	 */
redraw:function(){var e=this;if(e._map){
// Generate the mapped version of the data
var t=e._data.map(function(t){var n=e._fn.lng(t),i=e._fn.lat(t);return{o:t,point:e._project([n,i])}}),n=this._d3Container.selectAll("g.hexbin").data([this._map.getZoom()],function(t){return t}),i=n.enter().append("g").attr("class",function(t){return"hexbin zoom-"+t}).merge(n);
// Select the hex group for the current zoom level. This has
// the effect of recreating the group if the zoom level has changed
// exit
n.exit().remove(),
// add the hexagons to the select
this._createHexagons(i,t)}},_createHexagons:function(t,n){var i=this,e=i._map.getBounds(),o=i._hexLayout(n),a=i._getExtent(o,i._fn.colorValue,i.options.colorScaleExtent),s=i._getExtent(o,i._fn.radiusValue,i.options.radiusScaleExtent);
// Create the bins using the hexbin layout
if(!i.options.manualColorScaleDomain){
// Match the domain cardinality to that of the color range, to allow for a polylinear scale
var r=i._linearlySpace(a[0],a[1],i._scale.color.range().length);
// Set the scale domains
i._scale.color.domain(r)}
// Set the scale domains
i._scale.radius.domain(s),
/*
		 * Join
		 *    Join the Hexagons to the data
		 *    Use a deterministic id for tracking bins based on position
		 */
o=o.filter(function(t){return e.contains(i._map.layerPointToLatLng(L.point(t.x,t.y)))});var l=t.selectAll("g.hexbin-container").data(o,function(t){return t.x+":"+t.y});
/*
		 * Update
		 *    Set the fill and opacity on a transition
		 *    opacity is re-applied in case the enter transition was cancelled
		 *    the path is applied as well to resize the bins
		 */l.select("path.hexbin-hexagon").transition().duration(i.options.duration).attr("fill",i._fn.fill.bind(i)).attr("fill-opacity",i.options.opacity).attr("stroke-opacity",i.options.opacity).attr("d",function(t){return i._hexLayout.hexagon(i._scale.radius(i._fn.radiusValue.call(i,t)))}),
/*
		 * Grid Update
		 *    Update the hexbin grid handlers after data modification
		 */
l.select("path.hexbin-grid").style("pointer-events",i.options.pointerEvents).on("mouseover",function(t,n){i._hoverHandler.mouseover.call(this,i,t,n),i._dispatch.call("mouseover",this,t,n)}).on("mouseout",function(t,n){i._dispatch.call("mouseout",this,t,n),i._hoverHandler.mouseout.call(this,i,t,n)}).on("click",function(t,n){i._dispatch.call("click",this,t,n)});
/*
		 * Enter
		 *    Establish the path, size, fill, and the initial opacity
		 *    Transition to the final opacity and size
		 */
var u=l.enter().append("g").attr("class","hexbin-container");u.append("path").attr("class","hexbin-hexagon").attr("transform",function(t){return"translate("+t.x+","+t.y+")"}).attr("d",function(t){return i._hexLayout.hexagon(i._scale.radius.range()[0])}).attr("fill",i._fn.fill.bind(i)).attr("fill-opacity",.01).attr("stroke-opacity",.01).transition().duration(i.options.duration).attr("fill-opacity",i.options.opacity).attr("stroke-opacity",i.options.opacity).attr("d",function(t){return i._hexLayout.hexagon(i._scale.radius(i._fn.radiusValue.call(i,t)))}),
// Grid
u.append("path").attr("class","hexbin-grid").attr("transform",function(t){return"translate("+t.x+","+t.y+")"}).attr("d",function(t){return i._hexLayout.hexagon(i.options.radius)}).attr("fill","none").attr("stroke","none").style("pointer-events",i.options.pointerEvents).on("mouseover",function(t,n){i._hoverHandler.mouseover.call(this,i,t,n),i._dispatch.call("mouseover",this,t,n)}).on("mouseout",function(t,n){i._dispatch.call("mouseout",this,t,n),i._hoverHandler.mouseout.call(this,i,t,n)}).on("click",function(t,n){i._dispatch.call("click",this,t,n)});
// Exit
var c=l.exit();c.select("path.hexbin-hexagon").transition().duration(i.options.duration).attr("fill-opacity",0).attr("stroke-opacity",0).attr("d",function(t){return i._hexLayout.hexagon(0)}),c.transition().duration(i.options.duration).remove()},_getExtent:function(t,n,i){
// Determine the extent of the values
var e=u.extent(t,n.bind(this));
// If either's null, initialize them to 0
return null==e[0]&&(e[0]=0),null==e[1]&&(e[1]=0),
// Now apply the optional clipping of the extent
null!=i[0]&&(e[0]=i[0]),null!=i[1]&&(e[1]=i[1]),e},_project:function(t){var n=this._map.latLngToLayerPoint([t[1],t[0]]);return[n.x,n.y]},_getBounds:function(t){if(null==t||t.length<1)return{min:[0,0],max:[0,0]};
// bounds is [[min long, min lat], [max long, max lat]]
var e=[[999,999],[-999,-999]];return t.forEach(function(t){var n=t.point[0],i=t.point[1];e[0][0]=Math.min(e[0][0],n),e[0][1]=Math.min(e[0][1],i),e[1][0]=Math.max(e[1][0],n),e[1][1]=Math.max(e[1][1],i)}),{min:e[0],max:e[1]}},_linearlySpace:function(t,n,i){for(var e=new Array(i),o=(n-t)/Math.max(i-1,1),a=0;a<i;++a)e[a]=t+a*o;return e},
// ------------------------------------
// Public API
// ------------------------------------
radius:function(t){return arguments.length?(this.options.radius=t,this._hexLayout.radius(t),this):this.options.radius},opacity:function(t){return arguments.length?(this.options.opacity=t,this):this.options.opacity},duration:function(t){return arguments.length?(this.options.duration=t,this):this.options.duration},colorScaleExtent:function(t){return arguments.length?(this.options.colorScaleExtent=t,this):this.options.colorScaleExtent},radiusScaleExtent:function(t){return arguments.length?(this.options.radiusScaleExtent=t,this):this.options.radiusScaleExtent},colorRange:function(t){return arguments.length?(this.options.colorRange=t,this._scale.color.range(t),this):this.options.colorRange},radiusRange:function(t){return arguments.length?(this.options.radiusRange=t,this._scale.radius.range(t),this):this.options.radiusRange},colorScale:function(t){return arguments.length?(this._scale.color=t,this):this._scale.color},radiusScale:function(t){return arguments.length?(this._scale.radius=t,this):this._scale.radius},lng:function(t){return arguments.length?(this._fn.lng=t,this):this._fn.lng},lat:function(t){return arguments.length?(this._fn.lat=t,this):this._fn.lat},colorValue:function(t){return arguments.length?(this._fn.colorValue=t,this):this._fn.colorValue},radiusValue:function(t){return arguments.length?(this._fn.radiusValue=t,this):this._fn.radiusValue},fill:function(t){return arguments.length?(this._fn.fill=t,this):this._fn.fill},data:function(t){return arguments.length?(this._data=null!=t?t:[],this.redraw(),this):this._data},
/*
	 * Getter for the event dispatcher
	 */
dispatch:function(){return this._dispatch},hoverHandler:function(t){return arguments.length?(this._hoverHandler=null!=t?t:L.HexbinHoverHandler.none(),this.redraw(),this):this._hoverHandler},
/*
	 * Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
	 */
getLatLngs:function(){var n=this;
// Map the data into an array of latLngs using the configured lat/lng accessors
return this._data.map(function(t){return L.latLng(n.options.lat(t),n.options.lng(t))})},
/*
	 * Get path geometry as GeoJSON
	 */
toGeoJSON:function(){return L.GeoJSON.getFeature(this,{type:"LineString",coordinates:L.GeoJSON.latLngsToCoords(this.getLatLngs(),0)})}}),
// Hover Handlers modify the hexagon and can be combined
L.HexbinHoverHandler={tooltip:function(r){null==(
// merge options with defaults
r=r||{}).tooltipContent&&(r.tooltipContent=function(t){return"Count: "+t.length});
// Generate the tooltip
var l=u.select("body").append("div").attr("class","hexbin-tooltip").style("z-index",9999).style("pointer-events","none").style("visibility","hidden").style("position","fixed");
// return the handler instance
return l.append("div").attr("class","tooltip-content"),{mouseover:function(t,n){var i=u.event,e=u.mouse(this);l.style("visibility","visible").html(r.tooltipContent(n,t));var o=null;null!=l._groups&&0<l._groups.length&&0<l._groups[0].length&&(o=l._groups[0][0]);var a=o.clientHeight,s=o.clientWidth;l.style("top",""+i.clientY-e[1]-a-16+"px").style("left",""+i.clientX-e[0]-s/2+"px")},mouseout:function(t,n){l.style("visibility","hidden").html()}}},resizeFill:function(){
// return the handler instance
return{mouseover:function(n,t){u.select(this.parentNode).select("path.hexbin-hexagon").attr("d",function(t){return n._hexLayout.hexagon(n.options.radius)})},mouseout:function(n,t){u.select(this.parentNode).select("path.hexbin-hexagon").attr("d",function(t){return n._hexLayout.hexagon(n._scale.radius(n._fn.radiusValue.call(n,t)))})}}},resizeScale:function(i){
// return the handler instance
// merge options with defaults
return null==(i=i||{}).radiusScale&&(i.radiusScale=.5),{mouseover:function(n,t){u.select(this.parentNode).select("path.hexbin-hexagon").attr("d",function(t){return n._hexLayout.hexagon(n._scale.radius.range()[1]*(1+i.radiusScale))})},mouseout:function(n,t){u.select(this.parentNode).select("path.hexbin-hexagon").attr("d",function(t){return n._hexLayout.hexagon(n._scale.radius(n._fn.radiusValue.call(n,t)))})}}},compound:function(t){return null==(t=t||{}).handlers&&(t.handlers=[L.HexbinHoverHandler.none()]),{mouseover:function(n,i){var e=this;t.handlers.forEach(function(t){t.mouseover.call(e,n,i)})},mouseout:function(n,i){var e=this;t.handlers.forEach(function(t){t.mouseout.call(e,n,i)})}}},none:function(){return{mouseover:function(){},mouseout:function(){}}}},L.hexbinLayer=function(t){return new L.HexbinLayer(t)},
/**
 * L is defined by the Leaflet library, see git://github.com/Leaflet/Leaflet.git for documentation
 * We extend L.SVG to take advantage of built-in zoom animations.
 */
L.PingLayer=L.SVG.extend({includes:[L.Events],
/*
	 * Default options
	 */
options:{duration:800,fps:32,opacityRange:[1,0],radiusRange:[3,15]},
// Initialization of the plugin
initialize:function(t){L.setOptions(this,t),this._fn={lng:function(t){return t[0]},lat:function(t){return t[1]},radiusScaleFactor:function(t){return 1}},this._scale={radius:u.scalePow().exponent(.35),opacity:u.scaleLinear()},this._lastUpdate=Date.now(),this._fps=0,this._scale.radius.domain([0,this.options.duration]).range(this.options.radiusRange).clamp(!0),this._scale.opacity.domain([0,this.options.duration]).range(this.options.opacityRange).clamp(!0)},
// Called when the plugin layer is added to the map
onAdd:function(t){L.SVG.prototype.onAdd.call(this),
// Store a reference to the map for later use
this._map=t,
// Init the state of the simulation
this._running=!1,
// Set up events
t.on({move:this._updateContainer},this)},
// Called when the plugin layer is removed from the map
onRemove:function(t){L.SVG.prototype.onRemove.call(this),
// Destroy the svg container
this._destroyContainer(),
// Remove events
t.off({move:this._updateContainer},this),this._map=null,this._data=null},
/*
	 * Private Methods
	 */
// Initialize the Container - creates the svg pane
_initContainer:function(){L.SVG.prototype._initContainer.call(this),this._d3Container=u.select(this._container).select("g")},
// Update the container - Updates the dimensions of the svg pane
_updateContainer:function(){this._updatePings(!0)},
// Cleanup the svg pane
_destroyContainer:function(){
// Don't do anything
},
// Calculate the circle coordinates for the provided data
_getCircleCoords:function(t){var n=this._map.latLngToLayerPoint(t);return{x:n.x,y:n.y}},
// Add a ping to the map
_addPing:function(t,n){
// Lazy init the data array
null==this._data&&(this._data=[]);
// Derive the spatial data
var i=[this._fn.lat(t),this._fn.lng(t)],e=this._getCircleCoords(i),o={data:t,geo:i,ts:Date.now(),nts:0};o.c=this._d3Container.append("circle").attr("class",null!=n?"ping "+n:"ping").attr("cx",e.x).attr("cy",e.y).attr("r",this._fn.radiusScaleFactor.call(this,t)*this._scale.radius.range()[0]),
// Push new circles
this._data.push(o)},
// Main update loop
_updatePings:function(t){var n=Date.now();null==this._data&&(this._data=[]);
// Update everything
for(var i=-1,e=0;e<this._data.length;e++){var o=this._data[e],a=n-o.ts;if(this.options.duration<a)
// If the blip is beyond it's life, remove it from the dom and track the lowest index to remove
o.c.remove(),i=e;else
// If the blip is still alive, process it
if(t||o.nts<n){var s=this._getCircleCoords(o.geo);o.c.attr("cx",s.x).attr("cy",s.y).attr("r",this._fn.radiusScaleFactor.call(this,o.data)*this._scale.radius(a)).attr("fill-opacity",this._scale.opacity(a)).attr("stroke-opacity",this._scale.opacity(a)),o.nts=Math.round(n+1e3/this.options.fps)}}
// Delete all the aged off data at once
return-1<i&&this._data.splice(0,i+1),
// The return function dictates whether the timer loop will continue
this._running=0<this._data.length,this._running&&(this._fps=1e3/(n-this._lastUpdate),this._lastUpdate=n),!this._running},
// Expire old pings
_expirePings:function(){
// Search from the front of the array
for(var t=-1,n=Date.now(),i=0;i<this._data.length;i++){var e=this._data[i],o=n-e.ts;if(!(this.options.duration<o))break;
// If the blip is beyond it's life, remove it from the dom and track the lowest index to remove
e.c.remove(),t=i}
// Delete all the aged off data at once
-1<t&&this._data.splice(0,t+1)},
/*
	 * Public Methods
	 */
duration:function(t){return arguments.length?(this.options.duration=t,this):this.options.duration},fps:function(t){return arguments.length?(this.options.fps=t,this):this.options.fps},lng:function(t){return arguments.length?(this._fn.lng=t,this):this._fn.lng},lat:function(t){return arguments.length?(this._fn.lat=t,this):this._fn.lat},radiusRange:function(t){return arguments.length?(this.options.radiusRange=t,this._scale.radius().range(t),this):this.options.radiusRange},opacityRange:function(t){return arguments.length?(this.options.opacityRange=t,this._scale.opacity().range(t),this):this.options.opacityRange},radiusScale:function(t){return arguments.length?(this._scale.radius=t,this):this._scale.radius},opacityScale:function(t){return arguments.length?(this._scale.opacity=t,this):this._scale.opacity},radiusScaleFactor:function(t){return arguments.length?(this._fn.radiusScaleFactor=t,this):this._fn.radiusScaleFactor},
/*
	 * Method by which to "add" pings
	 */
ping:function(t,n){
// Start timer if not active
if(this._addPing(t,n),this._expirePings(),!this._running&&0<this._data.length){this._running=!0,this._lastUpdate=Date.now();var i=this;u.timer(function(){i._updatePings.call(i,!1)})}return this},getActualFps:function(){return this._fps},data:function(){return this._data}}),L.pingLayer=function(t){return new L.PingLayer(t)},Object.defineProperty(t,"__esModule",{value:!0})});
//# sourceMappingURL=leaflet-d3.js.map